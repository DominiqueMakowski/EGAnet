{
    "collab_server" : "",
    "contents" : "# Insteresting package:\n\n#https://www.rdocumentation.org/packages/WGCNA/versions/1.63/topics/mutualInfoAdjacency\n\n# Load the Packages:\nlibrary(psych)\nlibrary(Matrix)\nlibrary(entropy)\nlibrary(NetworkToolbox)\nlibrary(EGA)\n\n# Simulate data:\n\nf <-as.matrix(bdiag(rep(0.7, 4), rep(0.7, 4)))\nPhi <- matrix(0.5,2,2, byrow = T)\ndiag(Phi) <- 1\nPhi\nsim.1 <- sim.structure(fx = f, Phi = Phi, n = 5000, raw = TRUE, items = TRUE, cat = 1, low = -2.5, high = 2.5)\nsim.1 <- as.data.frame(sim.1$observed)\n\n\ntotcor <- totalCorMat(sim.1)\ndiag(totcor) <- 50\n\nlibrary(qgraph)\nqgraph(totcor, layout = \"spring\", diag = FALSE)\nEGA(totcor, model = \"TMFG\", n = 5000)\n\n# Apply EGA:\n\nega1 <- EGA(sim.1, model = \"TMFG\")\ncfa1 <- CFA(ega1, estimator = \"WLSMV\", data = sim.1)\nega2 <- ega1\nega2$dim.variables[,2] <- uniq.perm[61,]\nega3 <- ega1\nega3$dim.variables[,2] <- c(1,2,3,1,2,3,1,2)\n\ncfa2 <- CFA(ega2, estimator = \"WLSMV\", data = sim.1)\ncfa3 <- CFA(ega3, estimator = \"WLSMV\", data = sim.1)\ncfa2\ncfa1$fit.measures\nfitMeasures(cfa2$fit)\n\n\n# Generate the permutations of the item positions\n\nlibrary(\"gtools\")\nperm <- permutations(n = 8, r = 8, v = 1:8, repeats.allowed = FALSE)\n\n\npermutation.items2 <- matrix(0, nrow = nrow(perm), ncol = ncol(perm))\nfor(i in 1:nrow(perm)){\n  permutation.items2[i,] <- ega1$wc[order(perm[i,])]\n}\n\n# Take the unique values of the permutations:\n\nuniq.perm <- unique(permutation.items2)\nuniq.perm[1:35,]\n\n# Calculate the empirical entropy of the sum scores, per different\n# cluster:\n\nee <- vector()\nfor(i in 1:nrow(uniq.perm)){\n  ee[i] <-  entropy.empirical(apply(sim.1[, which(uniq.perm[i,] == 1)], 1, sum)) +\n           entropy.empirical(apply(sim.1[, which(uniq.perm[i,] == 2)], 1, sum))\n}\n\n\nplot(ee, type = \"o\")\n\njoint <- vector()\nfor(i in 1:nrow(uniq.perm)){\n  joint[i] <-  entropyFit(sim.1, uniq.perm[i,])$Adj.Entropy}\n\nplot(joint, type = \"o\")\n\n\njoint2 <- vector()\nfor(i in 1:nrow(uniq.perm)){\n  joint2[i] <-  entropyFit(sim.1, uniq.perm[i,])$H.Watanabe}\n\nplot(joint2, type = \"o\")\n\nentropyFit(sim.1, uniq.perm[1,])\nfat4 <- entropyFit(sim.1, c(1,1,2,2,3,3,4,4))\nsum(fat4$Ind.Entropy)\n\nvn <- vector()\nfor(i in 1:nrow(uniq.perm)){\n  vn[i] <-  vn.entropy(cor(sim.1), uniq.perm[i,])$Entropy.Fit}\n\nplot(vn, type = \"o\")\n\n# CFA INDEXES:\n\nega1 <- EGA(sim.1, model = \"TMFG\")\nega.all <- vector(\"list\", length = nrow(uniq.perm))\nfor(i in 1:length(ega.all)){\n  ega.all[[i]] <- ega1\n}\n\nfor(i in 1:length(ega.all)){\n  ega.all[[i]]$dim.variables[,2] <- uniq.perm[i,]\n}\n\ncfa.all <- vector(\"list\", length = nrow(uniq.perm))\nfor(i in 1:length(ega.all)){\n  cfa.all[[i]] <- CFA(ega.all[[i]], estimator = \"WLSMV\", data = sim.1, plot = FALSE)$fit.measures[4:5]\n}\n\ncfa2 <- CFA(ega2, estimator = \"WLSMV\", data = sim.1)\ncfa3 <- CFA(ega3, estimator = \"WLSMV\", data = sim.1)\n\n\ncfa2$fit.measures[4:5]\n\n\n\nvn1 <- vn.entropy(cor(sim.1), c(1,2,3,4,5,6,7,8))\n\nvn1.0 <- vn.entropy(cor(sim.1[,1:2]), c(1,2))\nvn1.01 <- vn.entropy(cor(sim.1[,2:3]), c(1,2))\nvn1.0$Tot.Entropy.VN+vn1.01$Tot.Entropy.VN\nvn1.1 <- vn.entropy(cor(sim.1[,1:3]), c(1,2,3))\n\nvn1.1$Fact.Entropy[1]+vn1.1$Fact.Entropy[2]+vn1.1$Fact.Entropy[2]+vn1.1$Fact.Entropy[3]\nvn1.1$Tot.Entropy.VN+vn1.1$Fact.Entropy[2]\nvn2 <- vn.entropy(cor(sim.1), uniq.perm[1,])\n\nvn.entropy(cor(sim.1), c(1,2,2,2,2,2,1,1))\n\ncor(joint, vn)\n\n\nentropyFit(sim.1, c(1,2,2,2,2,2,1,1))\nentropyFit(sim.1, uniq.perm[1,])\n\n\n\nentropyFit(sim.1, c(1,1,1,1,2,2,2,2))\nentropyFit(sim.1, c(1,2,3,4,5,6,7,8))\nvn.entropy(cor(sim.1), c(1,1,1,1,2,2,2,2))\nvn.entropy(cor(sim.1), c(1,2,3,4,5,6,7,8))\n\n-1.949242/3\n-1.462773/2\n\nvn.entropy\n\ncor(joint, joint2)\n\n\ninstall.packages(\"infotheo\")\nlibrary(infotheo)\n\na <- data.frame(X = rowSums(sim.1[,1:4]), Y = rowSums(sim.1[,5:8]))\n\nb <- entropyFit(sim.1, uniq.perm[1,])\n\n\n### Von Neumann Entropy:\n\nvn.entropy <- function(data, structure){\n  library(qgraph)\n  if(!is.matrix(data)){\n  cor1 <- cor_auto(data)\n  eigen.cor1 <- eigen(cor1)$values\n  l.eigen <- eigen.cor1*log(eigen.cor1)\n  h.vn <- -(sum(l.eigen))\n\n  n <- max(structure)\n  cor.fact <- vector(\"list\")\n  eigen.fact <- vector(\"list\")\n  l.eigen.fact <- vector(\"list\")\n  h.vn.fact <- vector(\"list\")\n  for(i in 1:n){\n    cor.fact[[i]] <- cor_auto(data[,which(structure==unique(structure)[i])])\n    eigen.fact[[i]] <- eigen(cor.fact[[i]])$values\n    l.eigen.fact[[i]] <- eigen.fact[[i]]*log(eigen.fact[[i]])\n    h.vn.fact[[i]] <- -(sum(l.eigen.fact[[i]]))\n  }\n  } else{\n    cor1 <- data\n    eigen.cor1 <- eigen(cor1)$values\n    l.eigen <- eigen.cor1*log(eigen.cor1)\n    h.vn <- -(sum(l.eigen))\n\n    n <- max(structure)\n    cor.fact <- vector(\"list\")\n    eigen.fact <- vector(\"list\")\n    l.eigen.fact <- vector(\"list\")\n    h.vn.fact <- vector(\"list\")\n    for(i in 1:n){\n      cor.fact[[i]] <- data[which(structure==unique(structure)[i]),which(structure==unique(structure)[i])]\n      eigen.fact[[i]] <- eigen(cor.fact[[i]])$values\n      l.eigen.fact[[i]] <- eigen.fact[[i]]*log(eigen.fact[[i]])\n      h.vn.fact[[i]] <- -(sum(l.eigen.fact[[i]]))\n    }\n}\n\n  h.vn.fact2 <- unlist(h.vn.fact)\n\n\n  results <- vector(\"list\")\n  results$Tot.Entropy.VN <- h.vn\n  results$Fact.Entropy <- h.vn.fact2\n  results$Sum.Fact.Entropy <- sum(h.vn.fact2)\n  results$Entropy.Fit <- mean(h.vn.fact2)-h.vn\n  return(results)\n}\n\n\nvn.entropy.sim1 <- vn.entropy(cor(sim.1), structure = c(1,2,3,4,5,6,7,8))\n\ninstall.packages(\"affy\")\n\ncor(sim.1)\n\ncor(joint2, vn)\n\n\ncor1 <- cov(sim.1)\nprec.matrix <- solve(cor1)\nlibrary(Matrix)\nkappa <- cov2cor(prec.matrix)\nkappa <- -1*kappa\ndiag(kappa) <- 1\nkappa <- forceSymmetric(kappa)\neigen.cor1 <- eigen(kappa)$values\nl.eigen <- eigen.cor1*log(eigen.cor1)\nh.vn <- -(sum(l.eigen))\n\nvn <- vector()\nfor(i in 1:nrow(uniq.perm)){\n  vn[i] <-  vn.entropy(cor(sim.1), uniq.perm[i,])$Mod.Entropy.Fit}\n\nplot(vn, type = \"o\")\n\ncor(vn, joint2)\n\n\n\n",
    "created" : 1543441836440.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1152628345",
    "id" : "43AC8F96",
    "lastKnownWriteTime" : 1543508271,
    "last_content_update" : 1543508271983,
    "path" : "~/Dropbox/Pacotes do R/Pacote EGA/New Functions to be Added/script_entropy_clusters_November.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}